# Implementation Plan: Langfuse Self-Hosting Integration

**Version:** v3.0
**Date:** 2025-11-01
**Last Updated By:** heiko
**Spec:** `docs/specs/spec_langfuse_self_hosting_v1.md` v1.0
**Estimated Effort:** 3-4 hours (Phase 1 - MVP with ClickHouse)

**ğŸ”´ STATUS: Phase 1 COMPLETE, Phase 2 IN PROGRESS**

**See:** `SWISPER_STUDIO_STATUS.md` for detailed current status

---

## Changelog

### v3.0 - 2025-11-01
- Updated status: Phase 1 complete (infrastructure)
- Documented rebrand fork creation
- Identified ZodError blocking issue
- Added status document reference

### v2.0 - 2025-11-01
- Added ClickHouse integration
- Updated with production-ready architecture

### v1.0 - 2025-11-01
- Initial implementation plan

---

## Overview

**Goal:** Deploy self-hosted Langfuse as "SwisperStudio" - branded LLM observability platform

**Strategic Context:**
- SwisperStudio is a **product feature** for Swisper SDK users
- SDK users will use it to debug their AI agents
- Competitive differentiator vs other AI SDKs

**What We've Built:**
1. âœ… Langfuse Web + Worker services in Docker Compose
2. âœ… Shared PostgreSQL database (`langfuse_db`)
3. âœ… **ClickHouse for analytics** (production-ready from day 1)
4. âœ… Environment configuration
5. âœ… Fork created and rebranded (`github.com/Sundi1972/swisper_studio`)
6. ğŸ”„ Basic tracing integration in backend (IN PROGRESS)

**Current Blocker:**
- âš ï¸ Custom SwisperStudio build has ZodError bug (fork based on `main` instead of `v2`)
- âš ï¸ Official Langfuse v2 not responding to health checks

**What We're NOT Building (Yet):**
- âŒ Prompt management (Phase 2)
- âŒ Advanced evaluations (Phase 3)
- âŒ Production deployment configuration (Future)

---

## Phase 1: Minimal Langfuse Setup (2-3 hours)

### Step 1: Generate Secrets (5 min)

**Generate required secrets:**

```bash
# NEXTAUTH_SECRET (min 32 chars)
openssl rand -base64 32

# SALT (encryption salt)
openssl rand -base64 32

# LANGFUSE_PUBLIC_KEY and LANGFUSE_SECRET_KEY
# Can use any string for local dev, will be replaced by Langfuse on first run
```

---

### Step 2: Update `.env` File (10 min)

**Add to `.env`:**

```bash
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Langfuse Configuration
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Enable/disable Langfuse
LANGFUSE_ENABLED=true

# Langfuse Host (for backend to connect)
LANGFUSE_HOST=http://langfuse-web:3000

# API Keys (will be generated by Langfuse on first run)
# These are placeholders - actual keys will be created in UI
LANGFUSE_PUBLIC_KEY=pk_local_dev_placeholder
LANGFUSE_SECRET_KEY=sk_local_dev_placeholder

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Langfuse Internal Configuration (for Langfuse services)
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Next.js Auth (REQUIRED - min 32 chars)
NEXTAUTH_SECRET=<paste_generated_secret_here>
NEXTAUTH_URL=http://localhost:3000

# Encryption Salt (REQUIRED)
SALT=<paste_generated_salt_here>

# Database URL for Langfuse
LANGFUSE_DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/langfuse_db

# Redis for Langfuse queue
LANGFUSE_REDIS_HOST=redis
LANGFUSE_REDIS_PORT=6379
LANGFUSE_REDIS_AUTH=

# S3/MinIO for Langfuse (optional - for exports)
LANGFUSE_S3_ENDPOINT=http://minio:9000
LANGFUSE_S3_ACCESS_KEY_ID=minioadmin
LANGFUSE_S3_SECRET_ACCESS_KEY=minioadmin
LANGFUSE_S3_BUCKET_NAME=langfuse-data
LANGFUSE_S3_REGION=us-east-1

# Disable telemetry for privacy
TELEMETRY_ENABLED=false

# Enable/disable specific features
LANGFUSE_ENABLE_EXPERIMENTAL_FEATURES=false

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ClickHouse Configuration (Analytics Database)
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# ClickHouse credentials
CLICKHOUSE_USER=langfuse
CLICKHOUSE_PASSWORD=<generate_secure_password>
CLICKHOUSE_DB=langfuse

# ClickHouse URL for Langfuse
CLICKHOUSE_URL=http://clickhouse:8123
```

---

### Step 3: Update `docker-compose.yml` (45 min)

**Add Langfuse services after the `llama` service:**

```yaml
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ClickHouse - Analytics Database for Langfuse
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  clickhouse:
    image: clickhouse/clickhouse-server:latest
    container_name: swisper-clickhouse
    restart: unless-stopped
    ports:
      - "8123:8123"  # HTTP interface
      - "9000:9000"  # Native protocol
    networks:
      - default
    volumes:
      - clickhouse-data:/var/lib/clickhouse
    environment:
      - CLICKHOUSE_DB=${CLICKHOUSE_DB:-langfuse}
      - CLICKHOUSE_USER=${CLICKHOUSE_USER:-langfuse}
      - CLICKHOUSE_PASSWORD=${CLICKHOUSE_PASSWORD}
      - CLICKHOUSE_DEFAULT_ACCESS_MANAGEMENT=1
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:8123/ping"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '1'
        reservations:
          memory: 1G

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Langfuse - LLM Observability Platform
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  langfuse-web:
    image: langfuse/langfuse:latest
    container_name: swisper-langfuse-web
    restart: unless-stopped
    ports:
      - "3000:3000"
    networks:
      - traefik-public
      - default
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
      clickhouse:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${LANGFUSE_DATABASE_URL}
      - NEXTAUTH_SECRET=${NEXTAUTH_SECRET}
      - NEXTAUTH_URL=${NEXTAUTH_URL}
      - SALT=${SALT}
      - TELEMETRY_ENABLED=${TELEMETRY_ENABLED:-false}
      - LANGFUSE_ENABLE_EXPERIMENTAL_FEATURES=${LANGFUSE_ENABLE_EXPERIMENTAL_FEATURES:-false}
      # Redis
      - REDIS_HOST=${LANGFUSE_REDIS_HOST:-redis}
      - REDIS_PORT=${LANGFUSE_REDIS_PORT:-6379}
      - REDIS_AUTH=${LANGFUSE_REDIS_AUTH:-}
      # ClickHouse
      - CLICKHOUSE_URL=${CLICKHOUSE_URL}
      - CLICKHOUSE_USER=${CLICKHOUSE_USER}
      - CLICKHOUSE_PASSWORD=${CLICKHOUSE_PASSWORD}
      # S3/MinIO (optional)
      - S3_ENDPOINT=${LANGFUSE_S3_ENDPOINT}
      - S3_ACCESS_KEY_ID=${LANGFUSE_S3_ACCESS_KEY_ID}
      - S3_SECRET_ACCESS_KEY=${LANGFUSE_S3_SECRET_ACCESS_KEY}
      - S3_BUCKET_NAME=${LANGFUSE_S3_BUCKET_NAME}
      - S3_REGION=${LANGFUSE_S3_REGION}
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/public/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    labels:
      - traefik.enable=true
      - traefik.docker.network=traefik-public
      - traefik.constraint-label=traefik-public
      - traefik.http.services.${STACK_NAME?Variable not set}-langfuse.loadbalancer.server.port=3000
      - traefik.http.routers.${STACK_NAME?Variable not set}-langfuse-http.rule=Host(`langfuse.${DOMAIN?Variable not set}`)
      - traefik.http.routers.${STACK_NAME?Variable not set}-langfuse-http.entrypoints=http
      - traefik.http.routers.${STACK_NAME?Variable not set}-langfuse-http.middlewares=https-redirect
      - traefik.http.routers.${STACK_NAME?Variable not set}-langfuse-https.rule=Host(`langfuse.${DOMAIN?Variable not set}`)
      - traefik.http.routers.${STACK_NAME?Variable not set}-langfuse-https.entrypoints=https
      - traefik.http.routers.${STACK_NAME?Variable not set}-langfuse-https.tls=true
      - traefik.http.routers.${STACK_NAME?Variable not set}-langfuse-https.tls.certresolver=le

  langfuse-worker:
    image: langfuse/langfuse-worker:latest
    container_name: swisper-langfuse-worker
    restart: unless-stopped
    networks:
      - default
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
      clickhouse:
        condition: service_healthy
      langfuse-web:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${LANGFUSE_DATABASE_URL}
      - NEXTAUTH_SECRET=${NEXTAUTH_SECRET}
      - SALT=${SALT}
      - TELEMETRY_ENABLED=${TELEMETRY_ENABLED:-false}
      # Redis
      - REDIS_HOST=${LANGFUSE_REDIS_HOST:-redis}
      - REDIS_PORT=${LANGFUSE_REDIS_PORT:-6379}
      - REDIS_AUTH=${LANGFUSE_REDIS_AUTH:-}
      # ClickHouse
      - CLICKHOUSE_URL=${CLICKHOUSE_URL}
      - CLICKHOUSE_USER=${CLICKHOUSE_USER}
      - CLICKHOUSE_PASSWORD=${CLICKHOUSE_PASSWORD}
      # S3/MinIO (optional)
      - S3_ENDPOINT=${LANGFUSE_S3_ENDPOINT}
      - S3_ACCESS_KEY_ID=${LANGFUSE_S3_ACCESS_KEY_ID}
      - S3_SECRET_ACCESS_KEY=${LANGFUSE_S3_SECRET_ACCESS_KEY}
      - S3_BUCKET_NAME=${LANGFUSE_S3_BUCKET_NAME}
      - S3_REGION=${LANGFUSE_S3_REGION}
    healthcheck:
      test: ["CMD-SHELL", "pgrep -f worker || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
```

**Note:** Add these to the `volumes` section (if not already there):

```yaml
volumes:
  # ... existing volumes ...
  clickhouse-data:
    driver: local
  langfuse-data:
    driver: local
```

---

### Step 4: Create `langfuse_db` Database (5 min)

**Create database initialization script:**

**File:** `scripts/init-langfuse-db.sh`

```bash
#!/bin/bash
set -e

echo "Creating langfuse_db database..."

# Run inside db container
docker compose exec -T db psql -U $POSTGRES_USER -d $POSTGRES_DB <<-EOSQL
    -- Create database if not exists
    SELECT 'CREATE DATABASE langfuse_db'
    WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'langfuse_db')\gexec

    -- Grant permissions
    GRANT ALL PRIVILEGES ON DATABASE langfuse_db TO $POSTGRES_USER;
EOSQL

echo "âœ… langfuse_db created successfully"
```

Make it executable:
```bash
chmod +x scripts/init-langfuse-db.sh
```

---

### Step 5: Create MinIO Bucket (5 min)

**File:** `scripts/init-langfuse-minio.sh`

```bash
#!/bin/bash
set -e

echo "Creating langfuse-data bucket in MinIO..."

# Install mc (MinIO client) if not present
docker compose exec -T minio sh -c "
    mc alias set local http://localhost:9000 minioadmin minioadmin
    mc mb local/langfuse-data --ignore-existing
    mc anonymous set download local/langfuse-data
"

echo "âœ… langfuse-data bucket created"
```

Make it executable:
```bash
chmod +x scripts/init-langfuse-minio.sh
```

---

### Step 6: Start Langfuse Services (15 min)

**Commands:**

```bash
# 1. Generate secrets (if not done already)
openssl rand -base64 32  # NEXTAUTH_SECRET
openssl rand -base64 32  # SALT
openssl rand -base64 16  # CLICKHOUSE_PASSWORD

# 2. Update .env with generated secrets

# 3. Pull Langfuse and ClickHouse images
docker compose pull langfuse-web langfuse-worker clickhouse

# 4. Start database and dependencies (if not running)
docker compose up -d db redis minio

# 5. Create langfuse_db database
./scripts/init-langfuse-db.sh

# 6. Create MinIO bucket
./scripts/init-langfuse-minio.sh

# 7. Start ClickHouse
docker compose up -d clickhouse

# Wait for ClickHouse to be healthy
docker compose ps clickhouse

# 8. Start Langfuse services
docker compose up -d langfuse-web langfuse-worker

# 9. Check logs
docker compose logs -f langfuse-web clickhouse

# 10. Wait for "ready" message and ClickHouse initialization
# ClickHouse: Watch for "Ready for connections"
# Langfuse: Watch for "Server listening" and "ClickHouse connected"
# May take 2-3 minutes for first startup
```

---

### Step 7: Access Langfuse UI (5 min)

**Access:**
- **URL:** http://localhost:3000
- **Or:** http://langfuse.localhost (if Traefik configured)

**First-time Setup:**
1. Open http://localhost:3000
2. Click "Sign up"
3. Create account (email: `admin@swisper.ai`, password: choose secure)
4. Create project: "Swisper Development"
5. Copy API keys:
   - Public Key: `pk-...`
   - Secret Key: `sk-...`
6. Update `.env`:
   ```bash
   LANGFUSE_PUBLIC_KEY=pk-...
   LANGFUSE_SECRET_KEY=sk-...
   ```

---

### Step 8: Install Langfuse Python SDK (10 min)

**Add to `backend/pyproject.toml`:**

```toml
[tool.poetry.dependencies]
# ... existing dependencies ...
langfuse = "^2.53.0"  # Check for latest version
```

**Install:**

```bash
cd backend
poetry add langfuse
```

**Or update `backend/requirements.txt` if using pip:**

```txt
langfuse>=2.53.0
```

---

### Step 9: Create Langfuse Service (20 min)

**File:** `backend/app/api/services/langfuse_service.py`

```python
"""
Langfuse integration service.

Provides tracing, observability, and prompt management.
"""

import os
from typing import Optional, Dict, Any
from functools import lru_cache
import logging

from langfuse import Langfuse

logger = logging.getLogger(__name__)


class LangfuseService:
    """
    Langfuse integration service.

    Handles:
    - Trace creation
    - Span tracking
    - Prompt versioning (future)
    - Metrics collection
    """

    def __init__(self):
        self.enabled = os.getenv("LANGFUSE_ENABLED", "false").lower() == "true"
        self.client: Optional[Langfuse] = None

        if self.enabled:
            self._initialize_client()

    def _initialize_client(self):
        """Initialize Langfuse client with config from env"""
        try:
            public_key = os.getenv("LANGFUSE_PUBLIC_KEY")
            secret_key = os.getenv("LANGFUSE_SECRET_KEY")
            host = os.getenv("LANGFUSE_HOST", "http://langfuse-web:3000")

            if not public_key or not secret_key:
                logger.warning(
                    "Langfuse enabled but API keys not set. "
                    "Set LANGFUSE_PUBLIC_KEY and LANGFUSE_SECRET_KEY."
                )
                self.enabled = False
                return

            self.client = Langfuse(
                public_key=public_key,
                secret_key=secret_key,
                host=host,
                debug=False,  # Set to True for verbose logging
            )

            logger.info(f"âœ… Langfuse initialized: {host}")

        except Exception as e:
            logger.error(f"Failed to initialize Langfuse: {e}")
            self.enabled = False

    def create_trace(
        self,
        name: str,
        user_id: Optional[str] = None,
        session_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
        tags: Optional[list[str]] = None,
    ):
        """
        Create a new trace.

        Args:
            name: Trace name (e.g., "fact_preloading", "chat_session")
            user_id: User identifier
            session_id: Session identifier
            metadata: Additional context
            tags: Tags for filtering

        Returns:
            Trace object or None if disabled
        """
        if not self.enabled or not self.client:
            return None

        try:
            return self.client.trace(
                name=name,
                user_id=user_id,
                session_id=session_id,
                metadata=metadata or {},
                tags=tags or [],
            )
        except Exception as e:
            logger.error(f"Failed to create trace: {e}")
            return None

    def flush(self):
        """Flush pending traces (call before shutdown)"""
        if self.enabled and self.client:
            try:
                self.client.flush()
            except Exception as e:
                logger.error(f"Failed to flush Langfuse: {e}")


# Singleton instance
@lru_cache(maxsize=1)
def get_langfuse_service() -> LangfuseService:
    """Get singleton Langfuse service"""
    return LangfuseService()
```

---

### Step 10: Add Test Trace (15 min)

**Add test endpoint to verify integration:**

**File:** `backend/app/api/routes/admin/__init__.py` (or create if missing)

```python
from fastapi import APIRouter

router = APIRouter()

# Import route modules
from . import langfuse_test  # noqa
```

**File:** `backend/app/api/routes/admin/langfuse_test.py`

```python
"""
Test endpoint for Langfuse integration.
"""

from fastapi import APIRouter, HTTPException
from typing import Dict, Any
import time

from app.api.services.langfuse_service import get_langfuse_service

router = APIRouter(prefix="/admin", tags=["admin"])


@router.post("/langfuse/test-trace")
async def test_langfuse_trace() -> Dict[str, Any]:
    """
    Test Langfuse integration by sending a test trace.

    Returns trace ID if successful.
    """
    langfuse = get_langfuse_service()

    if not langfuse.enabled:
        raise HTTPException(
            status_code=503,
            detail="Langfuse is not enabled. Set LANGFUSE_ENABLED=true in .env"
        )

    try:
        # Create test trace
        trace = langfuse.create_trace(
            name="langfuse_test",
            user_id="test_user",
            metadata={
                "source": "test_endpoint",
                "timestamp": time.time()
            },
            tags=["test", "health_check"]
        )

        if not trace:
            raise HTTPException(
                status_code=500,
                detail="Failed to create trace"
            )

        # Add a test span
        with trace.span(name="test_operation") as span:
            span.update(
                input={"message": "Testing Langfuse integration"},
                output={"status": "success"},
                metadata={"duration_ms": 100}
            )

        # Flush to ensure trace is sent
        langfuse.flush()

        return {
            "status": "success",
            "message": "Test trace sent to Langfuse",
            "trace_id": trace.id,
            "instructions": "Check Langfuse UI at http://localhost:3000"
        }

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to send test trace: {str(e)}"
        )


@router.get("/langfuse/status")
async def langfuse_status() -> Dict[str, Any]:
    """Check Langfuse integration status"""
    langfuse = get_langfuse_service()

    return {
        "enabled": langfuse.enabled,
        "client_initialized": langfuse.client is not None,
        "host": os.getenv("LANGFUSE_HOST", "not set"),
        "public_key_set": bool(os.getenv("LANGFUSE_PUBLIC_KEY")),
        "secret_key_set": bool(os.getenv("LANGFUSE_SECRET_KEY")),
    }
```

**Register routes in `backend/app/main.py`:**

```python
# Add to imports
from app.api.routes.admin import langfuse_test

# Add to route registration
app.include_router(langfuse_test.router, prefix="/api")
```

---

### Step 11: Test Integration (10 min)

**1. Restart backend:**

```bash
docker compose restart backend
```

**2. Check status:**

```bash
curl http://localhost:8000/api/admin/langfuse/status | jq
```

**Expected output:**

```json
{
  "enabled": true,
  "client_initialized": true,
  "host": "http://langfuse-web:3000",
  "public_key_set": true,
  "secret_key_set": true
}
```

**3. Send test trace:**

```bash
curl -X POST http://localhost:8000/api/admin/langfuse/test-trace | jq
```

**Expected output:**

```json
{
  "status": "success",
  "message": "Test trace sent to Langfuse",
  "trace_id": "abc123...",
  "instructions": "Check Langfuse UI at http://localhost:3000"
}
```

**4. Verify in Langfuse UI:**

- Open http://localhost:3000
- Click "Traces" in sidebar
- You should see "langfuse_test" trace
- Click to view details

---

### Step 12: Documentation (10 min)

**Create user guide:**

**File:** `docs/guides/langfuse_usage_guide.md`

```markdown
# Langfuse Usage Guide

**Version:** v1.0
**Last Updated:** 2025-11-01
**Last Updated By:** heiko
**Status:** Active

---

## Overview

Langfuse is integrated into Swisper for LLM observability, tracing, and prompt management.

---

## Accessing Langfuse

**Local Development:**
- URL: http://localhost:3000
- Or: http://langfuse.localhost

**Login:**
- Email: admin@swisper.ai (or your created account)
- Password: (set during first-time setup)

---

## Key Features

### 1. Traces
View execution traces of:
- Chat sessions
- Fact preloading
- Agent execution
- LLM calls

### 2. Metrics
Track:
- Cost per user/session
- Latency (P50, P95, P99)
- Token usage
- Error rates

### 3. Prompts (Future)
- Version control for prompts
- A/B testing
- Rollback capability

---

## Common Tasks

### View Recent Traces
1. Open http://localhost:3000
2. Click "Traces" in sidebar
3. Filter by user, session, or tag

### Debug Failed Request
1. Find trace in UI
2. Click to expand
3. View inputs, outputs, errors
4. Check span timings

### Track Costs
1. Go to "Dashboard"
2. View cost chart
3. Filter by date range

---

## For Developers

### Adding Traces to Code

```python
from app.api.services.langfuse_service import get_langfuse_service

langfuse = get_langfuse_service()

# Create trace
trace = langfuse.create_trace(
    name="my_operation",
    user_id=user_id,
    metadata={"context": "value"}
)

# Add span
with trace.span(name="step_1") as span:
    result = do_something()
    span.update(output={"result": result})
```

---

## Troubleshooting

### Traces Not Appearing

Check:
1. Langfuse enabled: `LANGFUSE_ENABLED=true` in `.env`
2. API keys set correctly
3. Backend can reach Langfuse: `curl http://langfuse-web:3000/api/public/health`
4. Check backend logs: `docker compose logs backend`

### Performance Issues

If Langfuse slows down backend:
1. Disable: `LANGFUSE_ENABLED=false`
2. Check resource usage: `docker stats`
3. Reduce trace volume (sample traces)

---

## Related Documentation

- Langfuse Docs: https://langfuse.com/docs
- Self-Hosting: https://langfuse.com/docs/self-hosting
- Spec: `docs/specs/spec_langfuse_self_hosting_v1.md`
- Plan: `docs/plans/plan_langfuse_self_hosting_v1.md`

---

**Questions?** Contact team or see Langfuse documentation.
```

---

## Testing Commands

```bash
# 1. Generate secrets
openssl rand -base64 32  # For NEXTAUTH_SECRET
openssl rand -base64 32  # For SALT

# 2. Update .env with secrets

# 3. Create databases and buckets
./scripts/init-langfuse-db.sh
./scripts/init-langfuse-minio.sh

# 4. Start Langfuse
docker compose up -d langfuse-web langfuse-worker

# 5. Check logs
docker compose logs -f langfuse-web langfuse-worker

# 6. Verify health
curl http://localhost:3000/api/public/health

# 7. Access UI
open http://localhost:3000

# 8. Test backend integration
curl http://localhost:8000/api/admin/langfuse/status | jq
curl -X POST http://localhost:8000/api/admin/langfuse/test-trace | jq

# 9. Check trace in UI
open http://localhost:3000/traces
```

---

## Definition of Done

### Phase 1 Complete When:
- âœ… Langfuse Web UI accessible at http://localhost:3000
- âœ… Langfuse Worker running
- âœ… `langfuse_db` database created
- âœ… Backend has Langfuse SDK installed
- âœ… Test trace sent successfully
- âœ… Trace visible in Langfuse UI
- âœ… All services healthy
- âœ… Documentation created

### Verification Checklist:
- [ ] `docker compose ps` shows all services healthy
- [ ] http://localhost:3000 loads
- [ ] Can create account and login
- [ ] API keys generated
- [ ] Backend status endpoint returns enabled=true
- [ ] Test trace appears in UI
- [ ] No errors in logs

---

## Rollback Plan

If issues occur:

1. **Disable Langfuse in backend:**
   ```bash
   # In .env
   LANGFUSE_ENABLED=false
   docker compose restart backend
   ```

2. **Stop Langfuse services:**
   ```bash
   docker compose stop langfuse-web langfuse-worker
   ```

3. **Remove services (if needed):**
   ```bash
   docker compose down langfuse-web langfuse-worker
   ```

4. **Clean up database:**
   ```sql
   DROP DATABASE langfuse_db;
   ```

---

## Next Steps (Phase 2)

After Phase 1 is complete:

1. **Add tracing to key services:**
   - `fact_preloading_service.py`
   - `orchestration_service.py`
   - `memory_node.py`

2. **Validate fact preloading metrics:**
   - Compare old vs new priority system
   - Track which facts get loaded
   - Measure performance impact

3. **Advanced features:**
   - Add ClickHouse for analytics
   - Migrate prompts to Langfuse
   - Setup evaluations

---

## Files Summary

### New Files (5)
1. `scripts/init-langfuse-db.sh` - Database setup
2. `scripts/init-langfuse-minio.sh` - Bucket setup
3. `backend/app/api/services/langfuse_service.py` - Integration service
4. `backend/app/api/routes/admin/langfuse_test.py` - Test endpoints
5. `docs/guides/langfuse_usage_guide.md` - User guide

### Modified Files (3)
1. `docker-compose.yml` - Add Langfuse services
2. `.env` - Add Langfuse configuration
3. `backend/pyproject.toml` - Add Langfuse SDK

### Scripts (2)
1. `scripts/init-langfuse-db.sh`
2. `scripts/init-langfuse-minio.sh`

---

## Estimated Time: 3.5-4 hours (with ClickHouse)

| Task | Time |
|------|------|
| Generate secrets | 10m |
| Update .env | 15m |
| Update docker-compose.yml | 45m |
| Create database | 5m |
| Create MinIO bucket | 5m |
| Start services (incl. ClickHouse) | 15m |
| Access UI and setup | 5m |
| Install SDK | 10m |
| Create service | 20m |
| Add test endpoint | 20m |
| Test integration | 15m |
| Documentation | 10m |
| **TOTAL** | **~3.5-4 hours** |

**Note:** ClickHouse adds ~1 hour to setup (image pull, initialization, configuration)

---

**Ready to implement!** Follow steps sequentially.

